{
  "name": "LRS10701 Uplink data converter for ChirpStack integration",
  "type": "UPLINK",
  "integrationType": "CHIRPSTACK",
  "debugMode": false,
  "debugSettings": {
    "failuresEnabled": true,
    "allEnabled": false,
    "allEnabledUntil": 1749487507263
  },
  "configuration": {
    "scriptLang": "TBEL",
    "decoder": null,
    "tbelDecoder": "var deviceType = metadata.deviceProfileName;\nvar fPort = metadata.fPort;\n\n/**\n * Decodes the incoming payload and returns a structured object containing telemetry data and attributes.\n *\n * @param {byte[]} input - The raw payload received as an array of bytes.\n * @returns {Object} output - The structured output with decoded telemetry and attributes.\n */\n\nfunction decodePayload(input) {\n    // Initialize the output object with empty attributes and telemetry for clarity.\n    var result = { attributes: {}, telemetry: {}};\n\n    // Decode serial number (SN) from the first 4 bytes of the payload.\n    // Press '?' icon in the top right corner to learn more about built in helper functions and capabilities.\n    result.attributes.sn = parseBytesToInt(input, 0, 4);\n\n    // Extract the timestamp from metadata (represented in milliseconds).\n    var timestamp = metadata.ts; // ts is the timestamp parsed from the incoming message's time, or returns the current time if it cannot be parsed.\n\n    // Initialize an object to store decoded key/value telemetry data.\n    var values = {};\n    if ((deviceType === 'LRS10701-OTAA') || (deviceType === 'LRS10701-ABP')) {\n        if (fPort === 10) {\n            // Decode event from the 1st byte of the payload.\n            values.event = parseBytesToInt(input, 0, 1);\n    \n            // Decode AQI, CO2 and temperature from the 2nd to 5th byte of the payload.\n            var AQI_CO2_T = parseBytesToInt(input, 1, 4);\n            values.aqi = AQI_CO2_T >> 23;\n            values.co2 = (AQI_CO2_T >> 10)&0x1FFF;\n            values.temperature = ((AQI_CO2_T & 0x3FF) - 300)*0.1;\n    \n            // Decode humidity from the 6th byte of the payload.\n            values.humidity = parseBytesToInt(input, 5, 1)*0.5;\n    \n            // Decode battery level and EC sensor resolution from the 11th byte of the payload.\n            var ecr_bat = parseBytesToInt(input, 10, 1);\n            var ec_res = ecr_bat >> 7;\n            if (ec_res === 1) \n                ec_scale = 10;\n            else\n                ec_scale = 1000;\n            values.battery = ecr_bat & 0x7F;\n            \n            // Decode gas sensor readings from the 7th to 8th and 9th to 10th byte of the payload.    \n            values.gas1 = parseBytesToInt(input, 6, 2)/ec_scale;\n            values.gas2 = parseBytesToInt(input, 8, 2)/ec_scale;\n        } else if (fPort === 11) {\n            // Decode TVOC from the 1st and 2nd byte of the payload.\n            values.tvoc = parseBytesToInt(input, 0, 2);\n            // Decode PM1.0 from the 3rd to 5th byte of the payload.\n            values[\"pm1.0\"] = parseBytesToInt(input, 2, 3)/1000;\n            // Decode PM2.5 from the 6th to 8th byte of the payload.\n            values[\"pm2.5\"] = parseBytesToInt(input, 5, 3)/1000;\n            // Decode PM10 from the 8th to 11th byte of the payload.\n            values.pm10 = parseBytesToInt(input, 8, 3)/1000;\n        }\n    }\n\n    if ((deviceType === 'LRS20100-OTAA') || (deviceType === 'LRS20100-ABP')) {\n        if (fPort === 10 && parseBytesToInt(input, 0, 1) === 1) {\n            // Decode event from the 2nd byte of the payload.\n            values.event = parseBytesToInt(input, 1, 1);\n    \n            // Decode temperature from the 4th and 5th byte of the payload.\n            var temperature = parseBytesToInt(input, 3, 2);\n            if (temperature > 32767) \n                temperature = temperature - 65536;\n            values.temperature = temperature/10;\n    \n            // Decode humidity from the 6th and 7th byte of the payload.\n            values.humidity = parseBytesToInt(input, 5, 2)/10;\n    \n            // Decode battery level the 3rd byte of the payload.\n            values.battery = parseBytesToInt(input, 2, 1);\n        }        \n    }\n\n    // Combine the timestamp with values and add it to the telemetry.\n    result.telemetry = {\n        ts: timestamp,\n        values: values\n    };\n\n    // Return the fully constructed output object.\n    return result;\n}\n\nvar result = decodePayload(payload);\n// Uncomment this code block to overwrite values set in the main configuration window. Useful if you extract device/asset/customer/group names from the payload;\n// result.type = 'DEVICE'; // Entity type allows you to choose type of created entity. Can be 'DEVICE' or 'ASSET'.\n// result.name = 'Temperature Sensor'; // Device or asset name (the value must be unique)\n// result.profile = 'IndustrialSensorProfile'; // Device or asset profile name.\n// result.customer = 'MyCustomer'; // If customer is not null - created entity will be assigned to customer with such name.\n// result.group = 'SensorsGroup'; // If group is not null - created entity will be added to the entity group with such name.\n\n// Return the final result object.\nreturn result;",
    "encoder": null,
    "tbelEncoder": null,
    "updateOnlyKeys": [
      "eui",
      "devAddr",
      "tenantId",
      "tenantName",
      "applicationId",
      "applicationName",
      "adr"
    ],
    "type": "DEVICE",
    "name": "Device $eui",
    "profile": "$deviceProfileName",
    "label": "$deviceName",
    "customer": "",
    "group": "",
    "telemetry": [
      "fCnt",
      "data",
      "rssi",
      "snr",
      "channel",
      "fPort"
    ],
    "attributes": [
      "eui",
      "tenantId",
      "tenantName",
      "applicationId",
      "applicationName",
      "adr"
    ]
  },
  "additionalInfo": {
    "description": ""
  },
  "edgeTemplate": false,
  "converterVersion": 2
}